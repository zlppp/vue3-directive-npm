import { Plugin } from 'vue';
import Form from './Form';
export { FormProps, formProps } from './Form';
export { FormItemProps, formItemProps } from './FormItem';
declare const _default: {
    new (...args: any[]): {
        $: import("vue").ComponentInternalInstance;
        $data: {};
        $props: Partial<{
            onSubmit: (...args: any[]) => any;
            prefixCls: string;
            name: string;
            model: {
                [key: string]: any;
            };
            validateMessages: {
                [key: string]: any;
            };
            onFinish: (...args: any[]) => any;
            onFinishFailed: (...args: any[]) => any;
        }> & Omit<Readonly<{
            onSubmit: (...args: any[]) => any;
            prefixCls: string;
            name: string;
            model: {
                [key: string]: any;
            };
            validateMessages: {
                [key: string]: any;
            };
            onFinish: (...args: any[]) => any;
            onFinishFailed: (...args: any[]) => any;
        } & {
            layout?: "inline" | "horizontal" | "vertical";
            colon?: boolean;
            validateTrigger?: string | string[];
            labelCol?: unknown;
            wrapperCol?: unknown;
            labelAlign?: "left" | "right";
            rules?: {
                [k: string]: import("./Form").ValidationRule | import("./Form").ValidationRule[];
            };
            hideRequiredMark?: boolean;
            validateOnRuleChange?: boolean;
            scrollToFirstError?: unknown;
        }> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps, "onSubmit" | "prefixCls" | "name" | "model" | "validateMessages" | "onFinish" | "onFinishFailed">;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("vue").Slot;
        }>;
        $root: import("vue").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>;
        $parent: import("vue").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>;
        $emit: (event: string, ...args: any[]) => void;
        $el: any;
        $options: import("vue").ComponentOptionsBase<Readonly<{
            onSubmit: (...args: any[]) => any;
            prefixCls: string;
            name: string;
            model: {
                [key: string]: any;
            };
            validateMessages: {
                [key: string]: any;
            };
            onFinish: (...args: any[]) => any;
            onFinishFailed: (...args: any[]) => any;
        } & {
            layout?: "inline" | "horizontal" | "vertical";
            colon?: boolean;
            validateTrigger?: string | string[];
            labelCol?: unknown;
            wrapperCol?: unknown;
            labelAlign?: "left" | "right";
            rules?: {
                [k: string]: import("./Form").ValidationRule | import("./Form").ValidationRule[];
            };
            hideRequiredMark?: boolean;
            validateOnRuleChange?: boolean;
            scrollToFirstError?: unknown;
        }>, {
            configProvider: import("../config-provider").ConfigConsumerProps;
            fields: any[];
            form: any;
            lastValidatePromise: any;
            vertical: import("vue").ComputedRef<boolean>;
        }, unknown, {}, {
            addField(field: any): void;
            removeField(field: any): void;
            handleSubmit(e: Event): void;
            getFieldsByNameList(nameList: import("./interface").NamePath): any[];
            resetFields(name: import("./interface").NamePath): void;
            clearValidate(name: import("./interface").NamePath): void;
            handleFinishFailed(errorInfo: import("./interface").ValidateErrorEntity<any>): void;
            validate(...args: any[]): Promise<any>;
            scrollToField(name: import("./interface").NamePath, options?: {}): void;
            getFieldsValue(nameList?: true | import("./interface").NamePath[]): any;
            validateFields(nameList?: import("./interface").NamePath[], options?: import("./interface").ValidateOptions): Promise<any>;
            validateField(...args: any[]): Promise<any>;
        }, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, Record<string, any>, string, {
            onSubmit: (...args: any[]) => any;
            prefixCls: string;
            name: string;
            model: {
                [key: string]: any;
            };
            validateMessages: {
                [key: string]: any;
            };
            onFinish: (...args: any[]) => any;
            onFinishFailed: (...args: any[]) => any;
        }>;
        $forceUpdate: import("vue").ReactiveEffect<any>;
        $nextTick: typeof import("vue").nextTick;
        $watch(source: string | Function, cb: Function, options?: import("vue").WatchOptions<boolean>): import("vue").WatchStopHandle;
    } & Readonly<{
        onSubmit: (...args: any[]) => any;
        prefixCls: string;
        name: string;
        model: {
            [key: string]: any;
        };
        validateMessages: {
            [key: string]: any;
        };
        onFinish: (...args: any[]) => any;
        onFinishFailed: (...args: any[]) => any;
    } & {
        layout?: "inline" | "horizontal" | "vertical";
        colon?: boolean;
        validateTrigger?: string | string[];
        labelCol?: unknown;
        wrapperCol?: unknown;
        labelAlign?: "left" | "right";
        rules?: {
            [k: string]: import("./Form").ValidationRule | import("./Form").ValidationRule[];
        };
        hideRequiredMark?: boolean;
        validateOnRuleChange?: boolean;
        scrollToFirstError?: unknown;
    }> & import("vue").ShallowUnwrapRef<{
        configProvider: import("../config-provider").ConfigConsumerProps;
        fields: any[];
        form: any;
        lastValidatePromise: any;
        vertical: import("vue").ComputedRef<boolean>;
    }> & {} & {} & {
        addField(field: any): void;
        removeField(field: any): void;
        handleSubmit(e: Event): void;
        getFieldsByNameList(nameList: import("./interface").NamePath): any[];
        resetFields(name: import("./interface").NamePath): void;
        clearValidate(name: import("./interface").NamePath): void;
        handleFinishFailed(errorInfo: import("./interface").ValidateErrorEntity<any>): void;
        validate(...args: any[]): Promise<any>;
        scrollToField(name: import("./interface").NamePath, options?: {}): void;
        getFieldsValue(nameList?: true | import("./interface").NamePath[]): any;
        validateFields(nameList?: import("./interface").NamePath[], options?: import("./interface").ValidateOptions): Promise<any>;
        validateField(...args: any[]): Promise<any>;
    } & import("vue").ComponentCustomProperties;
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("vue").ComponentOptionsBase<Readonly<{
    onSubmit: (...args: any[]) => any;
    prefixCls: string;
    name: string;
    model: {
        [key: string]: any;
    };
    validateMessages: {
        [key: string]: any;
    };
    onFinish: (...args: any[]) => any;
    onFinishFailed: (...args: any[]) => any;
} & {
    layout?: "inline" | "horizontal" | "vertical";
    colon?: boolean;
    validateTrigger?: string | string[];
    labelCol?: unknown;
    wrapperCol?: unknown;
    labelAlign?: "left" | "right";
    rules?: {
        [k: string]: import("./Form").ValidationRule | import("./Form").ValidationRule[];
    };
    hideRequiredMark?: boolean;
    validateOnRuleChange?: boolean;
    scrollToFirstError?: unknown;
}>, {
    configProvider: import("../config-provider").ConfigConsumerProps;
    fields: any[];
    form: any;
    lastValidatePromise: any;
    vertical: import("vue").ComputedRef<boolean>;
}, unknown, {}, {
    addField(field: any): void;
    removeField(field: any): void;
    handleSubmit(e: Event): void;
    getFieldsByNameList(nameList: import("./interface").NamePath): any[];
    resetFields(name: import("./interface").NamePath): void;
    clearValidate(name: import("./interface").NamePath): void;
    handleFinishFailed(errorInfo: import("./interface").ValidateErrorEntity<any>): void;
    validate(...args: any[]): Promise<any>;
    scrollToField(name: import("./interface").NamePath, options?: {}): void;
    getFieldsValue(nameList?: true | import("./interface").NamePath[]): any;
    validateFields(nameList?: import("./interface").NamePath[], options?: import("./interface").ValidateOptions): Promise<any>;
    validateField(...args: any[]): Promise<any>;
}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, Record<string, any>, string, {
    onSubmit: (...args: any[]) => any;
    prefixCls: string;
    name: string;
    model: {
        [key: string]: any;
    };
    validateMessages: {
        [key: string]: any;
    };
    onFinish: (...args: any[]) => any;
    onFinishFailed: (...args: any[]) => any;
}> & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps & {
    readonly Item: import("vue").DefineComponent<{
        id: import("vue-types").VueTypeValidableDef<string> & {
            default: string;
        };
        htmlFor: import("vue-types").VueTypeValidableDef<string> & {
            default: string;
        };
        prefixCls: import("vue-types").VueTypeValidableDef<string> & {
            default: string;
        };
        label: import("vue-types").VueTypeValidableDef<import("../_util/type").VueNode>;
        help: import("vue-types").VueTypeValidableDef<import("../_util/type").VueNode>;
        extra: import("vue-types").VueTypeValidableDef<import("../_util/type").VueNode>;
        labelCol: {
            type: import("vue").PropType<import("../grid/Col").ColProps>;
        };
        wrapperCol: {
            type: import("vue").PropType<import("../grid/Col").ColProps>;
        };
        hasFeedback: import("vue-types").VueTypeValidableDef<boolean> & {
            default: boolean;
        };
        colon: import("vue-types").VueTypeValidableDef<boolean>;
        labelAlign: import("vue-types").VueTypeDef<"left" | "right">;
        prop: {
            type: import("vue").PropType<string | number | string[] | number[]>;
        };
        name: {
            type: import("vue").PropType<string | number | string[] | number[]>;
        };
        rules: import("vue-types").VueTypeDef<unknown[] | {
            [key: string]: any;
        }>;
        autoLink: import("vue-types").VueTypeValidableDef<boolean> & {
            default: boolean;
        };
        required: import("vue-types").VueTypeValidableDef<boolean>;
        validateFirst: import("vue-types").VueTypeValidableDef<boolean>;
        validateStatus: import("vue-types").VueTypeDef<"" | "error" | "success" | "warning" | "validating">;
        validateTrigger: {
            type: import("vue").PropType<string | string[]>;
        };
        messageVariables: {
            type: import("vue").PropType<Record<string, string>>;
        };
    }, {
        isFormItemChildren: boolean;
        configProvider: import("../config-provider").ConfigConsumerProps;
        FormContext: any;
        fieldId: import("vue").ComputedRef<string>;
        fieldName: import("vue").ComputedRef<string | number | string[] | number[]>;
        namePath: import("vue").ComputedRef<import("./interface").InternalNamePath>;
        isRequired: import("vue").ComputedRef<boolean>;
        getRules: () => any[];
        fieldValue: import("vue").ComputedRef<any>;
        mergedValidateTrigger: import("vue").ComputedRef<any[]>;
    }, {
        validateState: "" | "error" | "success" | "warning" | "validating";
        validateMessage: string;
        validateDisabled: boolean;
        validator: {};
        helpShow: boolean;
        errors: any[];
        initialValue: any;
    }, {}, {
        getNamePath(): any[];
        validateRules(options: import("./interface").ValidateOptions): Promise<void> | Promise<string[]>;
        onFieldBlur(): void;
        onFieldChange(): void;
        clearValidate(): void;
        resetField(): void;
        getHelpMessage(): any;
        onLabelClick(): void;
        onHelpAnimEnd(_key: string, helpShow: boolean): void;
        renderHelp(prefixCls: string): JSX.Element;
        renderExtra(prefixCls: string): JSX.Element;
        renderValidateWrapper(prefixCls: string, c1: import("../_util/type").VueNode, c2: import("../_util/type").VueNode, c3: import("../_util/type").VueNode): JSX.Element;
        renderWrapper(prefixCls: string, children: import("../_util/type").VueNode): JSX.Element;
        renderLabel(prefixCls: string): JSX.Element;
        renderChildren(prefixCls: string, child: import("../_util/type").VueNode): JSX.Element[];
        renderFormItem(child: any[]): JSX.Element;
    }, {
        methods: {
            setState(state: {}, callback: any): void;
            __emit(...args: any[]): void;
        };
    }, import("vue").ComponentOptionsMixin, Record<string, any>, string, import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps, Readonly<{
        prefixCls: string;
        id: string;
        htmlFor: string;
        hasFeedback: boolean;
        autoLink: boolean;
    } & {
        label?: import("../_util/type").VueNode;
        help?: import("../_util/type").VueNode;
        name?: string | number | string[] | number[];
        extra?: import("../_util/type").VueNode;
        colon?: boolean;
        required?: boolean;
        validateTrigger?: string | string[];
        labelCol?: unknown;
        wrapperCol?: unknown;
        labelAlign?: "left" | "right";
        prop?: string | number | string[] | number[];
        rules?: unknown[] | {
            [key: string]: any;
        };
        validateFirst?: boolean;
        validateStatus?: "" | "error" | "success" | "warning" | "validating";
        messageVariables?: Record<string, string>;
    }>, {
        prefixCls: string;
        id: string;
        htmlFor: string;
        hasFeedback: boolean;
        autoLink: boolean;
    }>;
} & Plugin & {
    readonly Item: typeof Form.Item;
};
export default _default;
